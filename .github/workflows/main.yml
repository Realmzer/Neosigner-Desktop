name: Build macOS App

on:
  push:
    tags:
      - 'v*'
    branches:
      - main
  pull_request:
    branches:
      - main
  workflow_dispatch:  # Allow manual trigger

permissions:
  contents: write # Required for creating releases
  packages: read

jobs:
  build:
    runs-on: macos-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          submodules: recursive
      
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.10'
          cache: 'pip'
      
      - name: Install Python dependencies
        run: |
          python -m pip install --upgrade pip
          pip install pyinstaller pillow
          if [ -f requirements.txt ]; then pip install -r requirements.txt; fi
          
          # Verify tkinter is available (it's part of standard library)
          python -c "import tkinter; print('Tkinter is available, version:', tkinter.TkVersion)"
      
      - name: Clone zsign if needed
        run: |
          if [ ! -d "zsign" ]; then
            git clone https://github.com/zhlynn/zsign.git
          fi
      
      - name: Install build dependencies
        run: |
          brew update
          brew install pkg-config openssl@1.1 minizip
          brew install libimobiledevice ideviceinstaller create-dmg
      
      - name: Build zsign
        run: |
          cd zsign/build/macos
          make clean && make
          cd ../../..
          
          # Print where the binary is
          echo "Looking for zsign binary..."
          find zsign -name zsign -type f -exec ls -la {} \;
          
          # Create bin directory and copy zsign
          mkdir -p bin
          # Check if zsign is in zsign/bin
          if [ -f "zsign/bin/zsign" ]; then
            cp zsign/bin/zsign bin/
          # Or if it's directly in the build directory
          elif [ -f "zsign/build/macos/zsign" ]; then
            cp zsign/build/macos/zsign bin/
          else
            echo "Error: zsign binary not found!"
            exit 1
          fi
          chmod +x bin/zsign
          
          # Verify that zsign works
          bin/zsign -v
      
      - name: Create app bundle structure
        run: |
          # First, make sure our resources directory exists
          mkdir -p resources/bin
          
          # Copy zsign to resources/bin
          cp bin/zsign resources/bin/
          chmod +x resources/bin/zsign
          
          # Copy ideviceinstaller and dependencies
          IDEVICEINSTALLER_PATH=$(which ideviceinstaller)
          if [ -n "$IDEVICEINSTALLER_PATH" ]; then
            cp "$IDEVICEINSTALLER_PATH" resources/bin/
            chmod +x resources/bin/ideviceinstaller
          else
            echo "Warning: ideviceinstaller not found"
          fi
          
          # Copy libimobiledevice utilities
          for util in idevice_id ideviceinfo idevicename; do
            UTIL_PATH=$(which $util)
            if [ -n "$UTIL_PATH" ]; then
              cp "$UTIL_PATH" resources/bin/
              chmod +x resources/bin/$util
            fi
          done
          
          # Copy shared libraries that these binaries depend on
          for bin_file in resources/bin/*; do
            if [ -f "$bin_file" ] && [ -x "$bin_file" ]; then
              echo "Copying dependencies for $bin_file"
              otool -L "$bin_file" | grep -v "/System" | grep -v "/usr/lib" | awk '{print $1}' | while read -r lib; do
                if [[ "$lib" == *"/"* ]]; then
                  lib_base=$(basename "$lib")
                  echo "Copying $lib to resources/bin/$lib_base"
                  cp "$lib" "resources/bin/$lib_base" || echo "Failed to copy $lib"
                  # Fix the rpath in the binary
                  install_name_tool -change "$lib" "@executable_path/$lib_base" "$bin_file" || echo "Failed to change path for $lib in $bin_file"
                fi
              done
            fi
          done
          
          # List the resources/bin directory to verify
          echo "Contents of resources/bin:"
          ls -la resources/bin/
      
      - name: Create app launcher
        run: |
          cat > app_launcher.py << 'EOF'
          #!/usr/bin/env python3
          import os
          import sys
          import subprocess
          import tkinter as tk
          from tkinter import messagebox
          import shutil
          
          # Get the application path
          if getattr(sys, 'frozen', False):
              # Running as a bundled executable
              application_path = os.path.dirname(sys.executable)
              # For Mac app bundles, resources should be in various possible locations
              # List all possible bin paths in order of preference
              possible_bin_paths = [
                  os.path.join(application_path, 'bin'),                              # /Contents/MacOS/bin
                  os.path.join(os.path.dirname(application_path), 'Resources', 'bin') # /Contents/Resources/bin
              ]
              
              # Find the first valid bin path
              bin_path = None
              for path in possible_bin_paths:
                  if os.path.exists(path) and os.path.isdir(path):
                      bin_path = path
                      break
              
              # If no bin path found, create one
              if bin_path is None:
                  bin_path = os.path.join(application_path, 'bin')
                  os.makedirs(bin_path, exist_ok=True)
          else:
              # Running as a script
              application_path = os.path.dirname(os.path.abspath(__file__))
              bin_path = os.path.join(application_path, 'bin')
              if not os.path.exists(bin_path):
                  bin_path = os.path.join(application_path, 'resources', 'bin')
          
          print(f"Application path: {application_path}")
          print(f"Selected bin path: {bin_path}")
          
          # Add bin directory to PATH
          if bin_path and os.path.exists(bin_path):
              os.environ['PATH'] = f"{bin_path}:{os.environ.get('PATH', '')}"
              print(f"Added {bin_path} to PATH")
              
              # Debug: List bin directory contents
              print("Bin directory contents:")
              try:
                  for f in os.listdir(bin_path):
                      file_path = os.path.join(bin_path, f)
                      is_exec = os.access(file_path, os.X_OK)
                      print(f"  {f} - Executable: {is_exec}")
                  
                  # Make sure binaries are executable
                  for binary in os.listdir(bin_path):
                      binary_path = os.path.join(bin_path, binary)
                      if os.path.isfile(binary_path) and not os.access(binary_path, os.X_OK):
                          os.chmod(binary_path, 0o755)
                          print(f"Made {binary_path} executable")
              except Exception as e:
                  print(f"Error while accessing bin directory: {e}")
          else:
              print(f"Warning: No valid bin path found!")
              for path in possible_bin_paths:
                  print(f"  Checked: {path} - Exists: {os.path.exists(path)}")
              
              # Try to give more diagnostic info
              if getattr(sys, 'frozen', False):
                  print("App bundle structure:")
                  if os.path.exists(os.path.join(os.path.dirname(application_path), 'Resources')):
                      resources_dir = os.path.join(os.path.dirname(application_path), 'Resources')
                      print(f"Resources directory exists: {resources_dir}")
                      try:
                          print(f"Resources contents: {os.listdir(resources_dir)}")
                      except Exception as e:
                          print(f"Error listing Resources: {e}")
          
          # Import zsign_gui here to ensure PATH is set first
          try:
              import zsign_gui
          except ImportError as e:
              print(f"Error importing zsign_gui: {e}")
              tk.Tk().withdraw()
              messagebox.showerror("Error", f"Failed to import zsign_gui: {e}")
              sys.exit(1)
          
          # Define a function to find zsign binary
          def find_zsign_binary():
              # First check if zsign is in the bin path
              zsign_path = os.path.join(bin_path, "zsign")
              if os.path.exists(zsign_path) and os.access(zsign_path, os.X_OK):
                  return zsign_path
                  
              # Check if zsign is in PATH
              try:
                  zsign_in_path = shutil.which("zsign")
                  if zsign_in_path:
                      return zsign_in_path
              except:
                  pass
                  
              # Look in common locations
              search_paths = [
                  os.path.join(application_path, "zsign"),
                  os.path.join(application_path, "zsign_exe"),
                  os.path.join(application_path, "resources", "bin", "zsign"),
                  "/usr/local/bin/zsign",
              ]
              
              for path in search_paths:
                  if os.path.exists(path) and os.access(path, os.X_OK):
                      return path
                      
              return None
          
          # Check if zsign is available
          try:
              zsign_path = find_zsign_binary()
              
              if zsign_path:
                  print(f"Found zsign at: {zsign_path}")
                  
                  # If zsign isn't in bin_path, copy it there
                  if not os.path.exists(os.path.join(bin_path, "zsign")):
                      try:
                          dest_path = os.path.join(bin_path, "zsign")
                          shutil.copy2(zsign_path, dest_path)
                          os.chmod(dest_path, 0o755)
                          print(f"Copied zsign to bin directory: {dest_path}")
                      except Exception as e:
                          print(f"Error copying zsign: {e}")
                  
                  # Verify zsign works
                  result = subprocess.run([zsign_path, "-v"], 
                                      stdout=subprocess.PIPE, 
                                      stderr=subprocess.PIPE, 
                                      text=True)
                  print(f"zsign version check result: {result.returncode}")
                  print(f"zsign output: {result.stdout}")
                  if result.stderr:
                      print(f"zsign stderr: {result.stderr}")
              else:
                  print("Warning: zsign binary not found!")
                  if getattr(sys, 'frozen', False):
                      tk.Tk().withdraw()
                      messagebox.showwarning(
                          "Missing zsign", 
                          "The zsign binary was not found. The app may not function correctly. "
                          "Please use setup.sh to rebuild the application."
                      )
          except Exception as e:
              print(f"Error checking zsign: {e}")
          
          # Launch the GUI
          if __name__ == "__main__":
              try:
                  root = tk.Tk()
                  app = zsign_gui.ZsignGUI(root)
                  root.mainloop()
              except Exception as e:
                  print(f"Error launching app: {e}")
                  if 'root' in locals() and root.winfo_exists():
                      messagebox.showerror("Error", f"Failed to launch app: {e}")
                  else:
                      tk_root = tk.Tk()
                      tk_root.withdraw()
                      messagebox.showerror("Error", f"Failed to launch app: {e}")
                  sys.exit(1)
          EOF
      
      - name: Patch zsign_gui.py to improve binary detection
        run: |
          # Use sed to modify the find_zsign_binary method in zsign_gui.py
          cat > patch_zsign_gui.py << 'EOF'
          #!/usr/bin/env python3
          import os
          import re
          
          # Read the file
          with open('zsign_gui.py', 'r') as f:
              content = f.read()
          
          # Define the improved find_zsign_binary method
          new_find_zsign_binary = """    def find_zsign_binary(self):
              # Base directory is the directory containing this script
              base_dir = os.path.dirname(os.path.abspath(__file__))
              
              # Check if we're running as bundled app
              if getattr(sys, 'frozen', False):
                  # Running as a bundled executable
                  application_path = os.path.dirname(sys.executable)
                  
                  # Check in MacOS/bin directory first (highest priority)
                  macos_bin_path = os.path.join(application_path, 'bin', 'zsign')
                  if os.path.exists(macos_bin_path) and os.access(macos_bin_path, os.X_OK):
                      return macos_bin_path
                      
                  # Then check in Resources/bin
                  resources_bin_path = os.path.join(os.path.dirname(application_path), 'Resources', 'bin', 'zsign')
                  if os.path.exists(resources_bin_path) and os.access(resources_bin_path, os.X_OK):
                      return resources_bin_path
              
              # Standard search paths
              if sys.platform == "darwin":
                  # macOS
                  paths = [
                      os.path.join(base_dir, "bin", "zsign"),
                      os.path.join(base_dir, "zsign_exe"),
                      os.path.join(base_dir, "zsign/bin/zsign"),
                      os.path.join(base_dir, "build", "macos", "zsign"),
                      os.path.join(base_dir, "zsign"),
                      "/usr/local/bin/zsign",
                      "/usr/local/zsign/bin/zsign",
                      "/Users/local/zsign/bin/zsign",
                      "/usr/local/bin/zsign",
                      "/usr/local/zsign/bin/zsign",
                      "/zsign/bin/zsign",
                      "/local/zsign/bin/zsign",
                      "/usr/local/bin/zsign/bin/zsign",
                      "/usr/zsign/bin/zsign",
                      "/Users/local/Desktop/zsign/bin/zsign"
                  ]
              elif sys.platform.startswith("linux"):
                  # Linux
                  paths = [
                      os.path.join(base_dir, "build", "linux", "zsign"),
                      os.path.join(base_dir, "zsign"),
                      "/usr/local/bin/zsign"
                  ]
              elif sys.platform == "win32":
                  # Windows
                  paths = [
                      os.path.join(base_dir, "build", "windows", "vs2022", "x64", "Release", "zsign.exe"),
                      os.path.join(base_dir, "zsign.exe")
                  ]
              else:
                  # Unknown platform
                  return None
              
              # Check if binary exists and is executable
              for path in paths:
                  if os.path.exists(path):
                      if sys.platform != "win32":
                          # On Unix-like systems, check if the file is executable
                          if os.access(path, os.X_OK):
                              return path
                      else:
                          # On Windows, just check if it exists
                          return path
              
              return None"""
          
          # Replace the find_zsign_binary method
          content_modified = re.sub(
              r'def find_zsign_binary\(self\):.*?return None',
              new_find_zsign_binary,
              content,
              flags=re.DOTALL
          )
          
          # Write back to the file
          with open('zsign_gui.py', 'w') as f:
              f.write(content_modified)
          
          print("Updated zsign_gui.py with improved binary detection")
          EOF
          
          # Make the script executable and run it
          chmod +x patch_zsign_gui.py
          python3 patch_zsign_gui.py
      
      - name: Create simplified PyInstaller spec file
        run: |
          cat > iPASideloader.spec << EOF
          # -*- mode: python ; coding: utf-8 -*-

          block_cipher = None

          a = Analysis(
              ['app_launcher.py'],
              pathex=[],
              binaries=[
                  # Add zsign binary directly to ensure it gets properly included
                  ('bin/zsign', 'bin'),
                  # Add any other binaries from resources/bin to bin directly
                  ('resources/bin/ideviceinstaller', 'bin') if os.path.exists('resources/bin/ideviceinstaller') else None,
                  ('resources/bin/idevice_id', 'bin') if os.path.exists('resources/bin/idevice_id') else None,
                  ('resources/bin/ideviceinfo', 'bin') if os.path.exists('resources/bin/ideviceinfo') else None,
                  ('resources/bin/idevicename', 'bin') if os.path.exists('resources/bin/idevicename') else None,
              ],
              datas=[
                  ('resources/bin/*.dylib', 'bin'),
                  ('resources/bin/*.so*', 'bin'),
                  ('zsign_gui.py', '.'),
              ],
              hiddenimports=['tkinter', 'tkinter.ttk', 'tkinter.filedialog', 'tkinter.messagebox', 'tkinter.scrolledtext'],
              hookspath=[],
              hooksconfig={},
              runtime_hooks=[],
              excludes=[],
              win_no_prefer_redirects=False,
              win_private_assemblies=False,
              cipher=block_cipher,
              noarchive=False,
          )
          pyz = PYZ(a.pure, a.zipped_data, cipher=block_cipher)

          exe = EXE(
              pyz,
              a.scripts,
              [],
              exclude_binaries=True,
              name='iPASideloader',
              debug=False,
              bootloader_ignore_signals=False,
              strip=False,
              upx=True,
              console=True,  # Set to True for debugging
              disable_windowed_traceback=False,
              argv_emulation=True,
              target_arch=None,
              codesign_identity=None,
              entitlements_file=None,
          )
          coll = COLLECT(
              exe,
              a.binaries,
              a.zipfiles,
              a.datas,
              strip=False,
              upx=True,
              upx_exclude=[],
              name='iPASideloader',
          )
          app = BUNDLE(
              coll,
              name='iPASideloader.app',
              bundle_identifier='com.neoarz.ipasideloader',
              info_plist={
                  'CFBundleShortVersionString': '1.0.0',
                  'NSHighResolutionCapable': 'True'
              },
          )
          EOF
      
      - name: Build macOS app
        run: |
          pyinstaller --clean iPASideloader.spec
      
      - name: Verify app structure
        run: |
          echo "Checking app structure..."
          find dist/iPASideloader.app -type d | sort
          
          echo "Looking for zsign in the app bundle..."
          find dist/iPASideloader.app -name zsign -type f | xargs ls -la || echo "zsign not found in app bundle"
          
          echo "Checking resources directory..."
          ls -la dist/iPASideloader.app/Contents/Resources/resources/bin || echo "Resources/resources/bin not found"
          ls -la dist/iPASideloader.app/Contents/MacOS/resources/bin || echo "MacOS/resources/bin not found"
          
          echo "Contents of app bundle:"
          find dist/iPASideloader.app -type f -name "*.py" | sort
          
          echo "Checking if app launcher is properly included..."
          cat dist/iPASideloader.app/Contents/MacOS/iPASideloader || echo "Could not find app launcher"
      
      - name: Ensure binaries are properly included
        run: |
          # Create bin directory in the app bundle if it doesn't exist
          mkdir -p dist/iPASideloader.app/Contents/MacOS/bin
          
          echo "Copying zsign binary to multiple locations to ensure it's found..."
          
          # Copy zsign to the app bundle
          if [ -f "bin/zsign" ]; then
            echo "Copying zsign to app bundle bin directory..."
            cp bin/zsign dist/iPASideloader.app/Contents/MacOS/bin/
            chmod +x dist/iPASideloader.app/Contents/MacOS/bin/zsign
            
            # Also copy to Resources directory as a fallback
            mkdir -p dist/iPASideloader.app/Contents/Resources/bin
            cp bin/zsign dist/iPASideloader.app/Contents/Resources/bin/
            chmod +x dist/iPASideloader.app/Contents/Resources/bin/zsign
          else
            echo "WARNING: zsign binary not found in bin directory!"
          fi
          
          # Copy ideviceinstaller and other utilities if they exist
          for util in ideviceinstaller idevice_id ideviceinfo idevicename; do
            if [ -f "resources/bin/$util" ]; then
              echo "Copying $util to app bundle..."
              cp "resources/bin/$util" dist/iPASideloader.app/Contents/MacOS/bin/
              chmod +x dist/iPASideloader.app/Contents/MacOS/bin/$util
              
              # Also copy to Resources
              cp "resources/bin/$util" dist/iPASideloader.app/Contents/Resources/bin/
              chmod +x dist/iPASideloader.app/Contents/Resources/bin/$util
            fi
          done
          
          # Copy shared libraries
          echo "Copying shared libraries..."
          for lib in resources/bin/*.dylib resources/bin/*.so*; do
            if [ -f "$lib" ]; then
              echo "Copying $lib to app bundle..."
              cp "$lib" dist/iPASideloader.app/Contents/MacOS/bin/
              
              # Also copy to Resources
              cp "$lib" dist/iPASideloader.app/Contents/Resources/bin/
            fi
          done
          
          echo "Final app bundle bin directory contents:"
          ls -la dist/iPASideloader.app/Contents/MacOS/bin/
          ls -la dist/iPASideloader.app/Contents/Resources/bin/
      
      - name: Create zip of app
        run: |
          cd dist
          zip -r iPASideloader.zip iPASideloader.app
          cd ..
      
      - name: Get version from tag
        id: get_version
        run: |
          if [[ "$GITHUB_REF" == refs/tags/v* ]]; then
            VERSION=${GITHUB_REF#refs/tags/v}
            echo "VERSION=$VERSION" >> $GITHUB_OUTPUT
          else
            VERSION="dev-$(date +'%Y%m%d%H%M%S')"
            echo "VERSION=$VERSION" >> $GITHUB_OUTPUT
          fi
      
      - name: Rename zip
        run: |
          VERSION=${{ steps.get_version.outputs.VERSION }}
          mv dist/iPASideloader.zip "iPASideloader-$VERSION.zip"
      
      - name: Upload app as artifact
        uses: actions/upload-artifact@v4
        with:
          name: iPASideloader-${{ steps.get_version.outputs.VERSION }}
          path: iPASideloader-${{ steps.get_version.outputs.VERSION }}.zip
      
      - name: Create Release and Upload Asset
        if: startsWith(github.ref, 'refs/tags/v')
        uses: softprops/action-gh-release@v2
        with:
          files: iPASideloader-${{ steps.get_version.outputs.VERSION }}.zip
          draft: false
          prerelease: false
